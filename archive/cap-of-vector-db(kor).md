# CAP란?
- https://en.wikipedia.org/wiki/CAP_theorem

# CAP 설명
- 일관성(Consistency): 시스템의 모든 노드가 동일한 시간에 같은 데이터를 보여주는 정도를 말합니다. Pinecone은 강력한 일관성을 지향하는 반면, Elasticsearch와 Solr은 최종 일관성을 제공합니다. Milvus는 WAL과 복제를 통해 일관성을 강화합니다.
- 가용성(Availability): 요청을 받으면 항상 합법적인 응답을 반환하는 능력입니다. 모든 시스템은 다양한 복제 메커니즘과 장애 조치 전략을 사용하여 높은 가용성을 목표로 합니다.
- 분할 내성(Partition Tolerance): 네트워크 분할이 발생해도 시스템이 계속 작동할 수 있는 능력입니다. 모든 시스템은 분산 아키텍처를 기반으로 하여 높은 분할 내성을 제공합니다.

# VectorDB 별 달성 방법
| VectorDB |Consistency (일관성)| Availability (가용성)|Partition Tolerance (분할 내성)|
| --- | --- | --- | --- |
| Pinecone|강력한 일관성을 제공하기 위해 동기화된 복제 및 트랜잭션 로깅 사용|자동화된 복제와 장애 조치(failover) 메커니즘을 통해 가용성 보장|분산 아키텍처를 통해 네트워크 분할 시에도 서비스 운영 유지|
|Elasticsearch|최종 일관성 모델을 사용하며, 설정을 통해 일관성 수준 조정 가능|클러스터와 샤드를 통한 데이터 복제로 높은 가용성 달성|샤드와 레플리카를 통해 분할 내성 확보|
|Solr|최종 일관성 모델 사용, 동기/비동기 복제 옵션으로 일관성 수준 조절 가능|마스터-슬레이브 또는 클라우드 모드를 통한 가용성 보장|ZooKeeper를 사용한 클러스터 관리로 분할 내성 강화|
|Milvus|WAL(Write-Ahead Logging)과 동기화된 복제를 사용해 일관성 강화|데이터 복제 및 자동 장애 복구 메커니즘으로 가용성 확보|분산 시스템 설계로 높은 분할 내성 달성|

# 용어 설명
## 최종 일관성(Eventual Consistency) 모델
- 분산 시스템 내의 모든 복제본이 일정 시간이 지나면 최신 상태로 동기화될 것이라는 보장을 의미함
- 즉각적인 일관성(strong consistency)을 제공하지 않지만, 네트워크 분할이나 노드 장애와 같은 상황에서도 시스템의 가용성과 분할 내성을 유지할 수 있게 해줌
- Elasticsearch에서는 색인(index)된 문서가 즉시 모든 검색에 대해 가용되지 않을 수 있습니다. 
- 문서가 색인되면, 이 변경사항이 클러스터의 모든 복제본으로 전파되어야 하며, 이 과정에서 약간의 지연이 발생할 수 있습니다. 
- 이 지연 기간 동안 Elasticsearch는 최종 일관성을 보장합니다. 즉, 모든 복제본이 결국에는 최신 상태로 동기화되어 검색 결과에 반영됩니다.
- Elasticsearch는 '리프레시(refresh)'와 '플러시(flush)' 메커니즘을 사용하여 이를 관리합니다. 
- 리프레시 작업은 새로 색인된 데이터를 검색 가능하게 만들고, 플러시 작업은 데이터를 디스크에 영구적으로 저장합니다. 
- 기본적으로 Elasticsearch는 주기적으로 리프레시를 수행하여 검색 가능한 문서를 최신 상태로 유지합니다.
- 이러한 메커니즘을 통해 Elasticsearch는 네트워크 분할 또는 노드 장애가 발생하더라도 시스템의 가용성을 유지하면서 최종 일관성을 달성합니다.

## WAL(Write Ahead Logging)
- 트랜잭션이 일어나기 전에 로그를 미리 기록하는 방법
### WAL의 이점
- 내구성(Durability): 데이터베이스 시스템이 충돌한 경우에도, WAL은 마지막으로 확인된 안전 지점 이후의 모든 변경 사항을 복구할 수 있도록 보장합니다. 이는 데이터베이스의 내구성 요구사항을 충족시킵니다.
- 데이터 복구: 시스템 장애 후에 WAL을 사용하여 데이터베이스 상태를 신뢰할 수 있고 일관된 상태로 복구할 수 있습니다.
- 성능 향상: WAL을 사용하면 데이터베이스의 쓰기 연산이 로그 파일에 순차적으로 기록되므로, 랜덤 디스크 액세스보다 더 효율적으로 처리할 수 있습니다. 이는 특히 쓰기 연산이 빈번한 애플리케이션에서 성능 이점을 제공합니다.